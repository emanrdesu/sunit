#!/usr/bin/sidef

#`(if running under some shell) {
    eval 'exec /usr/bin/sidef $0 ${1+"$@"}'
}

# Author: Daniel "Trizen" Șuteu
# License: GPLv3
# Date: 17 May 2014
# Edit: 18 January 2020
# https://github.com/trizen/smart-units

# A pretty clever command-line units converter (written in Sidef).

# Get the Sidef programming language from:
#   https://github.com/trizen/sidef

define VERSION = 0.11

func more_help {
    <<"HELP"
Mass:
    42 kg to lbs        : convert kilograms to pounds
    30 t to grams       : convert tonnes to grams
    10 lbs to quintals  : convert pounds to quintals

Temperature:
    120 F to C          : convert fahrenheit to celsius
    -15 C to K          : convert celsius to kelvin
    420 K to F          : convert kelvin to fahrenheit

Length:
    21.1 in to cm       : convert inches to centimetres
    5.6 feet to m       : convert feet to meters
    4 light years to km : convert light years to km

Velocity:
    4444 mi/h to km/s   : convert miles per hour to km/s
    50 m/s to km/h      : convert meters per second to km/h
    42 ft/s in m/h      : convert feet/sec to meters/hour

Plane angle:
    2 rad in deg        : convert radians to degrees
    90 deg in rad       : convert degrees to radians

Frequency:
    30 MHz to Hz        : convert megahertz to hertz
    42 KHz to GHz       : convert kilohertz to gigahertz
    10 GHz to MHz       : convert gigahertz to megahertz

Time:
    2 hours in sec      : convert hours to seconds
    3 years in mons     : convert years to months
    4 days in hours     : convert days to hours

Information:
    32 MB in KB         : convert megabytes to kilobytes
    42 TiB in GiB       : convert tebibytes to gibibytes
    97 Gbit in MiB      : convert gigabits to mebibytes

...and more that are left for you to discover!
HELP
}

class Units {

    has conversions = :(
        mass => :(  # all relative to 1 kilogram
            nanograms    => :(re => /^(ng|nanograms?)$/in,          factor => 1e-12),
            micrograms   => :(re => /^(μg|micrograms?)$/in,         factor => 1e-9),
            milligrams   => :(re => /^(mg|mill?igrams?)$/in,        factor => 1e-6),
            centigrams   => :(re => /^(cg|centigrams?)$/in,         factor => 1e-5),
            decigrams    => :(re => /^(dg|decigrams?)$/in,          factor => 1e-4),
            grams        => :(re => /^(grams?|gr)$/in,              factor => 1e-3),
            decagrams    => :(re => /^(dag|decagrams?)$/in,         factor => 1e-2),
            hectograms   => :(re => /^(hg|hectograms?)$/in,         factor => 1e-1),
            kilograms    => :(re => /^(kg|kilograms?)$/in,          factor => 1),
            quintals     => :(re => /^(quintals?)$/in,              factor => 1e2),
            tonnes       => :(re => /^(tonn?es?|(?-i:t))$/in,       factor => 1e3),

            nanolitres   => :(re => /^(nl|nanolit(re|er)s?)$/in,    factor => 1e-9),
            microlitres  => :(re => /^(μl|microlit(re|er)s?)$/in,   factor => 1e-6),
            millilitres  => :(re => /^(ml|mill?ilit(re|er)s?)$/in,  factor => 1e-3),
            centilitres  => :(re => /^(cl|centilit(re|er)s?)$/in,   factor => 1e-2),
            decilitres   => :(re => /^(dl|decilit(re|er)s?)$/in,    factor => 1e-1),
            litres       => :(re => /^(l|lit(re|er)s?)$/in,         factor => 1),
            decalitres   => :(re => /^(dal|decalit(re|er)s?)$/in,   factor => 1e1),
            hectolitres  => :(re => /^(hl|hectolit(re|er)s?)$/in,   factor => 1e2),
            kilolitres   => :(re => /^(kl|kilolit(re|er)s?)$/in,    factor => 1e3),

            pounds       => :(re => /^(pounds?|lbs?)$/in,           factor => 0.45359237),
            stones       => :(re => /^(stones?|st)$/in,             factor => 6.35029318),
            gallons      => :(re => /^(gall?ons?|gall?s?)$/in,      factor => 3.78541),
        ),
        temperature => :(   # using Celsius as the standard
            celsius    => :(re => /^(celsius|(?-i:C))$/in,    code => {|n, _| n} ),
            kelvin     => :(re => /^(kelvin|(?-i:K))$/in,     code => {|n, to| to ? (n + 273.15) : (-273.15 + n)} ),
            fahrenheit => :(re => /^(fahrenheit|(?-i:F))$/in, code => {|n, to| to ? (32 + n*9/5) : ((n - 32) * 5/9)} ),
            rankine    => :(re => /^(rankine|(?-i:R))$/in,    code => {|n, to| to ? ((n + 273.15) * 9/5) : (n*5/9 - 273.15)} ),
        ),
        time => :(  # all relative to 1 second
            nanoseconds  => :(re => /^(nanosec(ond)?s?|(?-i:ns))/in,     factor => 1e-9),
            microseconds => :(re => /^(microsec(ond)?s?|(?-i:us))/in,    factor => 1e-6),
            milliseconds => :(re => /^(mill?isec(ond)?s?|(?-i:ms))$/in,  factor => 1e-3),
            seconds      => :(re => /^(sec(ond)?s?|(?-i:s))$/in,         factor => 1),
            minutes      => :(re => /^(min(ute)?s?)$/in,                 factor => 60),
            moments      => :(re => /^(mom(ent)?s?)$/in,                 factor => 90),
            hours        => :(re => /^(hours?)$/in,                      factor => 3600),
            days         => :(re => /^(days?)$/in,                       factor => 86400),
            millidays    => :(re => /^(millidays?|(?-i:md))$/in,         factor => 86.4),
            weeks        => :(re => /^(weeks?)$/in,                      factor => 604800),
            months       => :(re => /^(mon(th)?s?)$/in,                  factor => 2629743.83),
            years        => :(re => /^(years?)$/in,                      factor => 31556952),
        ),
        velocity    => :( # all relative to 1 meter / second
            meters_per_second     => :(re => /^ m(et(er|re)s?)? (\/|\s+per\s+) s(ec(ond)?)? $/inx,                    factor => 1),
            miles_per_hour        => :(re => /^ ( mph | mi(les?)? (\/|\s+per\s+) h(our)? ) $/inx,                     factor => 0.44704),
            miles_per_minute      => :(re => /^ ( mpm | mi(les?)? (\/|\s+per\s+) m(in(ute)?)? )$/inx,                 factor => 26.8224),
            miles_per_second      => :(re => /^ ( mps | mi(les?)? (\/|\s+per\s+) s(ec(ond)?)? )$/inx,                 factor => 1609.344),
            kilometers_per_hour   => :(re => /^ ( km?ph | k(ilo)?m(et(er|re)s?)? (\/|\s+per\s+) h(our)? )$/inx,       factor => 1/3.6),
            metres_per_hour       => :(re => /^ ( m(et(er|re)s?)? (\/|\s+per\s+) h(our)? ) $/inx,                     factor => 1/3600),
            kilometers_per_second => :(re => /^ ( km?ps | k(ilo)?m(et(er|re)s?)? (\/|\s+per\s+) s(ec(ond)?)? ) $/inx, factor => 1e3),
            speed_of_light        => :(re => /^ ( speed \s+ of \s+ light | (?-i:c) ) $/inx,                           factor => 299792458),
            speed_of_sound        => :(re => /^ ( speed \s+ of \s+ sound ) $/inx,                                     factor => 340.29),
        ),
        length      => :(   # all relative to 1 meter
            kilometers       => :(re => /^k(ilo)?m(et(er|re)s?)?$/in,      factor => 1e3),
            meters           => :(re => /^m(et(er|re)s?)?$/in,             factor => 1),
            centimetres      => :(re => /^(centimet(er|re)s?|cm)$/in,      factor => 1e-2),
            millimetres      => :(re => /^(millimet(er|re)s?|mm)$/in,      factor => 1e-3),
            micrometres      => :(re => /^(micromet(er|re)s?|um)$/in,      factor => 1e-6),
            nanometres       => :(re => /^(nanomet(er|re)s?|nm)$/in,       factor => 1e-9),
            picometres       => :(re => /^(picomet(er|re)s?|pm)$/in,       factor => 1e-12),
            femtometres      => :(re => /^(femtomet(er|re)s?|fm)$/in,      factor => 1e-15),
            feet             => :(re => /^(feet|ft|foot)$/in,              factor => 0.304799735),
            inches           => :(re => /^(inch(es)?|in|")$/in,            factor => 0.0254),
            miles            => :(re => /^(miles?|mi)$/in,                 factor => 1609.344),
            yards            => :(re => /^(yards?|yd)$/in,                 factor => 0.9144),
            astronomic_units => :(re => /^(astronomic[-\s]*units?|AU)$/in, factor => 149597870700),
            light_seconds    => :(re => /^(light[-\s]*sec(ond)?s?|ls)$/in, factor => 299792458),
            light_minutes    => :(re => /^(light[-\s]*min(ute)?s?|lm)$/in, factor => 1.798754748e10),
            light_hours      => :(re => /^(light[-\s]*hours?|lh)$/in,      factor => 1.0792528488e12),
            light_days       => :(re => /^(light[-\s]*days?|ld)$/in,       factor => 2.59020683712e13),
            light_years      => :(re => /^(light[-\s]*years?|ly)$/in,      factor => 9.4607304725808e15),
        ),
        information   => :( # all relative to 1 bit
            bits           => :(re => /^(bits?)$/in,          factor => 1),
            bytes          => :(re => /^(bytes?)$/in,         factor => 8),

            kilobits      => :(re => /^(kilobits?|Kbits?)$/in,  factor => 1000**1),
            megabits      => :(re => /^(megabits?|Mbits?)$/in,  factor => 1000**2),
            gigabits      => :(re => /^(gigabits?|Gbits?)$/in,  factor => 1000**3),
            terabits      => :(re => /^(terabits?|Tbits?)$/in,  factor => 1000**4),
            petabits      => :(re => /^(petabits?|Pbits?)$/in,  factor => 1000**5),
            exabits       => :(re => /^(exabits?|Ebits?)$/in,   factor => 1000**6),
            zettabits     => :(re => /^(zettabits?|Zbits?)$/in, factor => 1000**7),
            yottabits     => :(re => /^(yottabits?|Ybits?)$/in, factor => 1000**8),

            kibibits      => :(re => /^(kibibits?|Kibits?)$/in, factor => 1024**1),
            mebibits      => :(re => /^(mebibits?|Mibits?)$/in, factor => 1024**2),
            gibibits      => :(re => /^(gibibits?|Gibits?)$/in, factor => 1024**3),
            tebibits      => :(re => /^(tebibits?|Tibits?)$/in, factor => 1024**4),
            pebibits      => :(re => /^(pebibits?|Pibits?)$/in, factor => 1024**5),
            exbibits      => :(re => /^(exbibits?|Eibits?)$/in, factor => 1024**6),
            zebibits      => :(re => /^(zebibits?|Zibits?)$/in, factor => 1024**7),
            yobibits      => :(re => /^(yobibits?|Yibits?)$/in, factor => 1024**8),

            kilobytes      => :(re => /^(kilobytes?|kb)$/in,    factor => 8 * 1000**1),
            megabytes      => :(re => /^(megabytes?|mb)$/in,    factor => 8 * 1000**2),
            gigabytes      => :(re => /^(gigabytes?|gb)$/in,    factor => 8 * 1000**3),
            terabytes      => :(re => /^(terabytes?|tb)$/in,    factor => 8 * 1000**4),
            petabytes      => :(re => /^(petabytes?|pb)$/in,    factor => 8 * 1000**5),
            exabytes       => :(re => /^(exabytes?|eb)$/in,     factor => 8 * 1000**6),
            zettabytes     => :(re => /^(zettabytes?|zb)$/in,   factor => 8 * 1000**7),
            yottabytes     => :(re => /^(yottabytes?|yb)$/in,   factor => 8 * 1000**8),

            kibibytes      => :(re => /^(kibibytes?|kib)$/in,   factor => 8 * 1024**1),
            mebibytes      => :(re => /^(mebibytes?|mib)$/in,   factor => 8 * 1024**2),
            gibibytes      => :(re => /^(gibibytes?|gib)$/in,   factor => 8 * 1024**3),
            tebibytes      => :(re => /^(tebibytes?|tib)$/in,   factor => 8 * 1024**4),
            pebibytes      => :(re => /^(pebibytes?|pib)$/in,   factor => 8 * 1024**5),
            exbibytes      => :(re => /^(exbibytes?|eib)$/in,   factor => 8 * 1024**6),
            zebibytes      => :(re => /^(zebibytes?|zib)$/in,   factor => 8 * 1024**7),
            yobibytes      => :(re => /^(yobibytes?|yib)$/in,   factor => 8 * 1024**8),
        ),
        plane_angle => :(   # all relative to 1 radian
            radian  =>  :(re => /^(rad(ians?)?)$/in,   factor => 1),
            degree  =>  :(re => /^(deg(rees?)?)$/in,   factor => Num.pi/180),
        ),
        frequency => :(     # all relative to 1 hertz
            hertz     => :(re => /^(hertz|hz)$/in,         factor => 1),
            kilohertz => :(re => /^(kiloherz|khz)$/in,     factor => 1e3),
            megahertz => :(re => /^(megahertz|mhz)$/in,    factor => 1e6),
            gigahertz => :(re => /^(gigahertz|ghz)$/in,    factor => 1e9),
        ),
    )

    method convert(amount, from, to) {
        conversions.each { |category, value|
            value.each { |from_unit, from_data|
                if (from.match(from_data{:re})) {
                    value.each_v{ |to_data|
                        if (to.match(to_data{:re})) {
                            var result = 0
                            if (from_data.has_key(:code) && to_data.has_key(:code)) {
                                var std_from = from_data{:code}(amount, false)
                                result   = to_data{:code}(std_from, true)
                            } else {
                                result = (amount / to_data{:factor} * from_data{:factor})
                            }
                            return result
                        }
                    }
                    STDERR.say("#{category}: I don't know how to convert #{from_unit.gsub('_', ' ')} to #{to}...")
                    return nil
                }
            }
        }

        STDERR.say("I don't know how to convert #{from} to #{to}... Is '#{from}' a real unit?")
        return nil
    }
}

var precision = 10
var interactive = false

func help {
    <<"USAGE"
usage: #{File.new(__FILE__).basename} [text]

options:
    -i     : start in interactive mode (default: #{interactive})
    -p int : set floating point precision (default: #{precision})

examples:
    144 F to C
    convert 10kg into pounds
    whats the equivalent of 21 inches in meters
    what is the speed of light in miles per hour
USAGE
}

func round_result (value, precision) {
    value.is_int ? value : value.round(-precision)
}

func process_input (command) {

    static units = Units()

    var match = command.match(/^\s*

        # command or question
        (?:(?:convert|how\s+much\s+is|what(?:\s+is|\W*s)(?:\s+the)?(?:\s+equivalent\s+of)?)\s+)?

        # followed by a number or 'a' word or nothing
        ([-+]?\d+(?:\.\d+)?|(?:an?|one)(?=\s)|)

        # unit from (up to 3 words)
        \s*(\S+(?:\s+\S+){0,2})

        # 'to' token
        \s+(?:in|to|into|as)\s+

        # unit to (up to 3 words)
        (\S+(?:\s+\S+){0,2})
    \s*$/ix)

    if (match) {
        var (amount, from, to) = match...

        if (amount ~~ ['a','an','one','']) {
            amount = 1
        }
        else {
            amount = Number(amount)
        }

        var m1 = (from =~ %r{(.+?)/(.+)})
        var m2 = (to   =~ %r{(.+?)/(.+)})

        if (m1 && m2) {

            static time_aliases = :(
                m => 'min',
                h => 'hour',
                s => 'sec',
                d => 'day',
                w => 'week',
                y => 'year',
            )

            var len1 = m1[0]
            var len2 = m2[0]

            var time1 = time_aliases.fetch(m1[1].lc, m1[1])
            var time2 = time_aliases.fetch(m2[1].lc, m2[1])

            var r1 = units.convert(1, len1,  len2)
            var r2 = units.convert(1, time1, time2)

            if (defined(r1) && defined(r2)) {
                return round_result(amount * r1/r2, precision)
            }
        }

        with (units.convert(amount, from, to)) { |r|
            return round_result(r, precision)
        }
    }
    else {
        return try { eval(command) }
    }

    return nil
}

if (__FILE__ == __MAIN__) {

    var cmd = []

    while (ARGV) {
        given (var arg = ARGV.shift) {
            when ('-p') {
                precision = Num(ARGV.shift)
            }
            when ('-i') {
                interactive = true
            }
            when ('-h') {
                print help()
                Sys.exit(0)
            }
            when ('-v') {
                say "smart-units #{VERSION}"
                Sys.exit(0)
            }
            default {
                cmd << arg
            }
        }
    }

    if (cmd.is_empty && STDIN.is_on_tty) {
        interactive = true
    }

    if (interactive) {
        print <<-"EOT"
        Welcome to smart-units #{VERSION} in interactive mode.
        EOT
        loop {
            var line = read(">> ", String) \\ break

            if (line ~~ ['q', 'exit']) {
                break
            }

            if (line =~ /help/i) {
                print more_help()
                next
            }

            line =~ /\S/ || next

            with (process_input(line)) {|r|
                say r
            }
        }
    }
    else {
        cmd || do { print help(); Sys.exit(1) }
        with (process_input(cmd.join(' '))) { |r|
            say r
        }
        else {
            Sys.exit(1)
        }
    }
}
